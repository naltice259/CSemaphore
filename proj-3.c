//Nicholas Altice
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "threads.h"


int a = 0;
int b = 0;
int e = 0;
int f = 0;
int size = 0;
Semaphore *Producer;
Semaphore *Consumer;
int* buff;
int in = 0;
int out = 0;

void profunction(int producerID);
void confunction(int consumerID);

int main()
{
	
    char c[17];
    fgets(c, 17, stdin); //get input
    int i = 0;
    while(c[i] >= 48 && c[i] <= 57 && i < 17){
    	a = (a * 10) + (c[i] - '0'); //get thread number
    	i++;
	}
	i++;
	while(c[i] >= 48 && c[i] <= 57 && i < 17){
    	b = (b * 10) + (c[i] - '0'); //get execution number
    	i++;
	}
	i++;
	while(c[i] >= 48 && c[i] <= 57 && i < 17){
    	e = (e * 10) + (c[i] - '0'); //get execution number
    	i++;
	}
	i++;
	while(c[i] >= 48 && c[i] <= 57 && i < 17){
    	f = (f * 10) + (c[i] - '0'); //get execution number
    	i++;
	}
	Producer = (struct Semaphore*)malloc(sizeof(struct Semaphore));
	Consumer = (struct Semaphore*)malloc(sizeof(struct Semaphore));
	buff = (int*)malloc(a * sizeof(int));
	InitSem(&Producer, a);
	InitSem(&Consumer, 0);
	size = b+e;
	int q[size];
    for(int z = 0;z < size; z++){
    	scanf("%d", &q[z]);
	}
	for(int z = 0;z < size; z++){
		if(q[z] > 0){
			start_thread(profunction, q[z]);
		}else{
			start_thread(confunction, q[z]);
		}
	}
    run();
    return 0;
}

void profunction(int producerID)
{
	int local = 0;
	while(local < f)
	{
		P(&Producer, producerID);
		local++;
		buff[in] = producerID;
		in = (in + 1) % a;
		printf("\n Producer %d is producing item number %d \n", producerID, local);
		V(&Consumer);
	}
	for(int z = 0;z < 300; z++){
    	yield();
	}
	return;
}

void confunction(int consumerID)
{
	int cID = -1 * consumerID;
	int producerID;
	int local = 0;
	while(local < f)
	{
		P(&Consumer, consumerID);
		local++;
		producerID = buff[out];
		out = (out + 1) % a;
		printf("\n Consumer %d is consuming item generated by Producer %d \n", cID, producerID);
		V(&Producer);
	}
	for(int z = 0;z < 300; z++){
    	yield();
	}
	return;
}
